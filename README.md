# OpenAPI generated server

Spring Boot Server - Version 0.0.1-alpha

## Overview
This server was generated by the [OpenAPI Generator](https://openapi-generator.tech) project.
By using the [OpenAPI-Spec](https://openapis.org), you can easily generate a server stub.
This is an example of building a OpenAPI-enabled server in Java using the SpringBoot framework.


The underlying library integrating OpenAPI to Spring Boot is [springdoc](https://springdoc.org).
Springdoc will generate an OpenAPI v3 specification based on the generated Controller and Model classes.
The specification is available to download using the following url:
http://localhost:8080/v3/api-docs/

Start your server as a simple java application

You can view the api documentation in swagger-ui by pointing to
http://localhost:8080/swagger-ui.html

Change default port value in application.properties

## Inter-Server API Communication

This project supports inter-server communication through generated client code. The OpenAPI Generator creates both server and client code from the same specification, ensuring type safety and consistency across services.

### Client Code Generation

The project includes Java client generation configured in `java-client-generator.yml`. To generate client code for consuming this API from other services:

```bash
mvn clean generate-sources
```

This generates:
- **API Client Classes**: Type-safe client interfaces for each API endpoint
- **Model Classes**: POJOs for request/response objects
- **Configuration**: Client configuration and authentication support

### Example: Inter-Service Communication

Here's how to use the generated client to call this API from another Spring Boot service:

#### 1. Add Client Dependencies

```xml
<dependency>
    <groupId>me.xstr</groupId>
    <artifactId>api-spec</artifactId>
    <version>0.0.1-alpha</version>
    <classifier>client</classifier>
</dependency>
```

#### 2. Configure API Client

```java
@Configuration
public class ApiClientConfig {
    
    @Bean
    public ApiClient apiClient() {
        ApiClient client = new ApiClient();
        client.setBasePath("http://localhost:8080"); // Target service URL
        client.setConnectTimeout(5000);
        client.setReadTimeout(10000);
        return client;
    }
    
    @Bean
    public HealthApi healthApi(ApiClient apiClient) {
        return new HealthApi(apiClient);
    }
    
    @Bean
    public InfoApi infoApi(ApiClient apiClient) {
        return new InfoApi(apiClient);
    }
}
```

#### 3. Use Client in Service

```java
@Service
public class ExternalServiceCaller {
    
    private final HealthApi healthApi;
    private final InfoApi infoApi;
    
    public ExternalServiceCaller(HealthApi healthApi, InfoApi infoApi) {
        this.healthApi = healthApi;
        this.infoApi = infoApi;
    }
    
    /**
     * Check health of remote service
     */
    public HealthResponse checkRemoteHealth() {
        try {
            return healthApi.getHealth();
        } catch (ApiException e) {
            log.error("Failed to check remote health: {}", e.getMessage());
            throw new ServiceUnavailableException("Remote service health check failed");
        }
    }
    
    /**
     * Get version information from remote service
     */
    public VersionResponse getRemoteVersion() {
        try {
            return infoApi.getVersion();
        } catch (ApiException e) {
            log.error("Failed to get remote version: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Async health check with circuit breaker pattern
     */
    @Async
    @CircuitBreaker(name = "remoteHealth", fallbackMethod = "fallbackHealth")
    @Retry(name = "remoteHealth")
    @TimeLimiter(name = "remoteHealth")
    public CompletableFuture<HealthResponse> checkRemoteHealthAsync() {
        return CompletableFuture.completedFuture(healthApi.getHealth());
    }
    
    public CompletableFuture<HealthResponse> fallbackHealth(Exception ex) {
        HealthResponse fallback = new HealthResponse();
        fallback.setStatus(HealthResponse.StatusEnum.DOWN);
        fallback.setTimestamp(OffsetDateTime.now());
        fallback.setVersion("0.0.1-alpha");
        return CompletableFuture.completedFuture(fallback);
    }
}
```

#### 4. Error Handling and Resilience

```java
@Component
public class ResilientApiCaller {
    
    private final HealthApi healthApi;
    
    public ResilientApiCaller(HealthApi healthApi) {
        this.healthApi = healthApi;
    }
    
    /**
     * Call with retry and timeout handling
     */
    public Optional<HealthResponse> callWithResilience() {
        return Try.of(() -> healthApi.getHealth())
            .recover(throwable -> {
                if (throwable instanceof ApiException) {
                    ApiException apiEx = (ApiException) throwable;
                    log.warn("API call failed with status {}: {}", 
                            apiEx.getCode(), apiEx.getMessage());
                }
                return null;
            })
            .toJavaOptional();
    }
}
```

### Service Discovery Integration

For microservices architectures, integrate with service discovery:

```java
@Component
public class ServiceDiscoveryApiClient {
    
    @Value("${services.xstr-api.name:xstr-api}")
    private String serviceName;
    
    private final DiscoveryClient discoveryClient;
    
    public ServiceDiscoveryApiClient(DiscoveryClient discoveryClient) {
        this.discoveryClient = discoveryClient;
    }
    
    @Bean
    public ApiClient dynamicApiClient() {
        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);
        if (instances.isEmpty()) {
            throw new IllegalStateException("No instances found for service: " + serviceName);
        }
        
        ServiceInstance instance = instances.get(0); // or implement load balancing
        String baseUrl = String.format("http://%s:%d", 
                instance.getHost(), instance.getPort());
        
        ApiClient client = new ApiClient();
        client.setBasePath(baseUrl);
        return client;
    }
}
```

### Authentication Integration

For secured inter-service communication:

```java
@Configuration
public class SecuredApiClientConfig {
    
    @Bean
    public ApiClient securedApiClient(@Value("${api.auth.token}") String authToken) {
        ApiClient client = new ApiClient();
        client.setBasePath("http://localhost:8080");
        
        // Add authentication
        client.setApiKey(authToken);
        client.setApiKeyPrefix("Bearer");
        
        return client;
    }
}
```

### Best Practices

1. **Connection Pooling**: Configure HTTP client connection pooling for better performance
2. **Circuit Breakers**: Use circuit breaker patterns for fault tolerance
3. **Retries**: Implement exponential backoff retry strategies
4. **Timeouts**: Set appropriate connection and read timeouts
5. **Monitoring**: Add metrics and tracing for inter-service calls
6. **Caching**: Cache responses when appropriate to reduce network calls

### Configuration Properties

```yaml
# application.yml
xstr:
  api:
    client:
      base-url: http://localhost:8080
      connect-timeout: 5000
      read-timeout: 10000
      max-retries: 3
      circuit-breaker:
        failure-threshold: 5
        reset-timeout: 30000
```